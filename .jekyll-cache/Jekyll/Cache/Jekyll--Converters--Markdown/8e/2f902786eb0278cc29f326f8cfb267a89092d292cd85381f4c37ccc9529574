I"e/<p>对项目中用到的东西进行了回顾，首先就是分布式事物框架TX-LCN</p>

<h2 id="catagory">Catagory</h2>

<ol>
  <li><a href="#分布式事务是什么">分布式事务是什么</a></li>
  <li><a href="#两大理论依据">两大理论依据</a>
    <ol>
      <li><a href="#cap">CAP</a></li>
      <li><a href="#base">BASE</a></li>
    </ol>
  </li>
  <li><a href="#常见的分布式事务解决方案">常见的分布式事务解决方案</a>
    <ol>
      <li><a href="#xa模式">XA模式</a></li>
      <li><a href="#lcn框架">LCN框架</a>
        <ol>
          <li><a href="#tx-lcn">TX-LCN</a></li>
          <li><a href="#tcc">TCC</a></li>
          <li><a href="#txc">TXC</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#tx-lcn事务协调机制">TX-LCN事务协调机制</a></li>
  <li><a href="#tx-lcn事务补偿机制">TX-LCN事务补偿机制</a></li>
  <li><a href="#总结">总结</a></li>
</ol>

<hr />

<h2 id="分布式事务是什么">分布式事务是什么</h2>
<p>随着互联化的蔓延，各种项目都逐渐向分布式服务做转换。如今微服务已经普遍存在，本地事务已经无法满足分布式的要求，由此分布式事务问题诞生。
引用百度百科的解释：分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
也就是说，一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，
要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。
举例来说，现在大家都习惯于网上购物，如果去做一个电商购物系统，那么订单是一个模块，商品库存是另一个模块。
在购物的时候，涉及到订单数量+1以及商品库存-1.当要处理的事务不再存在于一个模块中，购物最终的结果只能是订单数量+1，商品库存-1
或者订单数量-1，商品库存+1，不能存在订单数量变化而商品库存没变或者商品库存变化而订单数量没变的情况。这就是数据一致性。</p>

<hr />

<h2 id="两大理论依据">两大理论依据</h2>
<p>分布式事务被称为世界性的难题，目前分布式事务存在两大理论依据：CAP定律 BASE理论。</p>
<h3 id="cap">CAP</h3>
<p>这个定理的内容是指的是在一个分布式系统中、Consistency（一致性）、 Availability（可用性）、
Partition tolerance（分区容错性），三者不可得兼。基于分布式系统的要求，分区容错性是必须要满足的，那么就
只能在AC之间做取舍，AP，CP</p>

<p>一致性C:在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本)</p>

<p>可用性A:在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p>

<p>分区容错型P:分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务</p>

<h3 id="base">BASE</h3>
<p>BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。
BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结， 是基于CAP定理逐步演化而来的。
BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>

<p>基本可用：指分布式系统在出现不可预知故障的时候，允许损失部分可用性。这不等价于系统不可用，比如响应时间上的损失，功能上的损失（熔断）等。</p>

<p>软状态：允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。即允许系统在不同节点的数据副本之间
进行数据同步的过程存在延时。</p>

<p>最终一致性：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致性的状态。因此最终一致性的本质是需要
系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>

<hr />

<h2 id="常见的分布式事务解决方案">常见的分布式事务解决方案</h2>
<h3 id="xa模式">XA模式</h3>
<p>XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。
 其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p>

<p>XA需要两阶段提交: prepare 和 commit. 
 第一阶段为 准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager（事务管理器）报告已准备就绪。 
 第二阶段为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。 </p>

<p>总结来说：因为XA 事务是基于两阶段提交协议的，所以需要有一个事务管理器（transaction manager）来保证所有的事务参与者都完成了准备工作(第一阶段)。
 如果事务管理器（transaction manager）收到所有参与者都准备好的消息，就会通知所有的事务都可以提交了（第二阶段）。
 MySQL 在这个XA事务中扮演的是参与者的角色，而不是事务管理器（transaction manager）。虽然XA比较简单，使用分布式事务成本也比较低，但是，XA也存在致命缺点，
 性能不理想（比如，prepare阶段中某个参与者线程阻塞，那么全体参与者都会在prepare阶段等待阻塞线程的顺利执行，浪费资源），无法满足高并发场景</p>

<h3 id="lcn框架">LCN框架</h3>
<p>在XA协议无法满足高并发场景的情况下，诞生了LCN框架。LCN代表着锁定事务单元(lock)，确认事务模块状态(confirm)，通知事务(notify)。
LCN框架在2017年6月份发布第一个版本，从开始的1.0，已经发展到了5.0版本。
5.0以后由于框架兼容了LCN、TCC、TXC三种事务模式，为了避免区分LCN模式，特此将LCN分布式事务改名为TX-LCN分布式事务框架。</p>
<h4 id="tx-lcn">TX-LCN</h4>
<p>TX-LCN是通过代理Connection的方式实现对本地事务的操作，然后在由TxManager统一协调控制事务。当本地事务提交回滚或者关闭连接时将会执行假操作，该代理的连接将由LCN连接池管理。</p>
<ul>
  <li>该模式对代码嵌入性很低</li>
  <li>该模式仅限于本地存在连接对象且可通过连接对象控制事务的模块</li>
  <li>该模式下的事务提交与回滚是由本地事务方控制，对于数据一致性上有较高的保障</li>
  <li>该模式缺陷在于代理的连接需要随事务发起方一共释放连接，增加了连接占用时间</li>
</ul>

<h4 id="tcc">TCC</h4>
<p>TCC事务机制相对于传统事务机制（X/Open XA Two-Phase-Commit），其特征在于它不依赖资源管理器(RM)对XA的支持，而是通过对（由业务系统提供的）业务逻辑的调度来实现分布式事务。
主要由三步操作，Try: 尝试执行业务、 Confirm:确认执行业务、 Cancel: 取消执行业务。</p>

<p>所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。
以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。
在高并发场景，TCC优势很大，因为其在第一阶段就把事务提交了，不需要在后面像XA一样继续持有数据库的锁，影响并发的性能，因为TCC的第二阶段是一个确认（Confirm）的阶段，
也就是说只需要调用各个子系统里的confirm逻辑，把原来没有更新到数据库的那些 “缓存” 数据更新到数据库，因为这个时候已经把更改的数据缓存起来了，只是还没更新到数据库，所以在执行confirm逻辑的时候，并不会持有数据库的锁。
但是，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。</p>

<ul>
  <li>该模式对代码的嵌入性高，要求每个业务需要写三种步骤的操作。</li>
  <li>该模式对有无本地事务控制都可以支持使用面广。</li>
  <li>数据一致性控制几乎完全由开发者控制，对业务开发难度要求高。</li>
</ul>

<h4 id="txc">TXC</h4>
<p>TXC模式命名来源于淘宝，实现原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快走信息和创建锁。当需要回滚的时候就采用这些记录数据回滚数据库，目前锁实现依赖redis分布式锁控制。</p>

<ul>
  <li>该模式同样对代码的嵌入性低。</li>
  <li>该模式仅限于对支持SQL方式的模块支持。</li>
  <li>该模式由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式消耗资源与时间要多。</li>
  <li>该模式不会占用数据库的连接资源。</li>
</ul>

<hr />

<h2 id="tx-lcn事务协调机制">TX-LCN事务协调机制</h2>
<p>TX-LCN的口号是：TX-LCN并不生产事务，TX-LCN只是本地事务的协调工。那么它是怎么协调呢，是怎么控制各个模块在完成事务的逻辑
操作之后不立马提交，而是等到TxManager最后一起通知各模块提交的呢？因为每个模块都是一个TxClient，每个TxClient下
都有一个连接池，是框架自定义的连接池，对Connection使用静态代理的方式进行包装。连接池在没有接收到通知事务之前会一直
占有着这次分布式事务的连接资源，等到最后TxManager通知TxClient时，TxClient才会去执行相应的提交或回滚。所以协调机制相当于
是<strong>拦截了一下连接池，控制了连接的事务提交</strong></p>

<hr />

<h2 id="tx-lcn事务补偿机制">TX-LCN事务补偿机制</h2>
<p>由于我们不能保证事务每次都正常执行，如果在执行某个业务方法时，本应该执行成功的操作却因为服务器挂机或网络抖动等问题导致事务没有正常提交，这种场景就需要通过补偿来完成事务。
在这种情况下TxManager会做一个标示;然后返回给发起方。告诉他本次事务有存在没有通知到的情况，然后TxClient再次执行该次请求事务。</p>

<h2 id="总结">总结</h2>
<p>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：不控制、部分控制和完全控制。
不控制就是不引入分布式事务，部分控制就是各种变种的两阶段提交（TCC模式等），而完全控制就是完全实现两阶段提交。
部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性。
具体用哪种方式，最终还是取决于业务场景。作为技术人员，一定不能忘了技术是为业务服务的，不要为了技术而技术，针对不同业务进行技术选型也是一种很重要的能力！</p>

<h2 id="参考资料">参考资料</h2>
<ul>
  <li><small><a href="https://www.cnblogs.com/tanshaoshenghao/p/11684727.html">浅谈分布式事务与TX-LCN</a></small></li>
  <li><small><a href="https://blog.csdn.net/Maxiao1204/article/details/103618851">TCC和XA区别</a></small></li>
  <li><small><a href="http://www.txlcn.org/zh-cn/docs/preface.html">TX-LCN分布式事务框架</a></small></li>
</ul>

:ET